---
title: fastapi-tutorial-3
date: 2023-06-18 07:51:11
tags: [fastapi, tech]
---

## Dependency

### Dependency in common parameters

The first usage of `Depends` will be common parameter inputs of the functions.

``` python
from fastapi import Depends

async def common_parameters(
    q: Union[str, None] = None, 
    skip: int = 0, 
    limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

CommonsDep = Annotated[dict, Depends(common_parameters)]

@app.get("/items/")
async def read_items(commons: CommonsDep):
    return commons

@app.get("/users/")
async def read_users(commons: CommonsDep):
    return commons
```

### Dependency in class

Another form of dependency using class as common parameters.

``` python
class CommonQueryParams:
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit

@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
...
```


### Dependency in path operations

The dependencies do not need to have return values. They can be only the functions that needed to be executed.

``` python
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

### Global dependencies

Global dependencies can be defined as following,

``` python
app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])
```

### Yield dependencies

Only the code prior to and including the `yield` statement is executed before sending a response. The code following the `yield` statement is executed after the response has been delivered. So that each database session will be ensured to be closed.


``` python
async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()
```


## Security

The whole security codes are too long to display here. One can refer to the [link](https://fastapi.tiangolo.com/tutorial/security/).

In the login page,

``` python
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@app.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    ...
    return {"access_token": access_token, "token_type": "bearer"}
```

`OAuth2PasswordBearer(tokenUrl="token")` will be specifying which URL for the user to send username and password to. In the page `/token`, the user should be expected to get a token with type to be `bearer`.

Then the security system needs a function to generate access token from `username`, `secret key` and `algorithm`. In this case, we will be using `JWT tokens`. Hence, we need to install the following package to get JWT tokens.

``` bash
$ pip install "python-jose[cryptography]"
```

The secret key can be generated by the bash command.

``` bash
$ openssl rand -hex 32
```

Then we can define the following parameters and generate the token.

``` python
from jose import JWTError, jwt

SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
data={"sub": user.username}

encoded_jwt = jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)
```

After getting the token, functions and pages need to verify the user is authenticated with the token by `Depends(oauth2_scheme)`. 

``` python
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
   ...
```

Often, it is necessary to do a second verification that the token is valid and user encoded in the token is a valid user.

``` python
payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
username: str = payload.get("sub")
```

Furthermore, we need to pay attention to the hashing of the passwords. We use `passlib` here to handle the hashing. The algorithm used here is `bcrypt`.

``` bash
$ pip install "passlib[bcrypt]"
```

To use `passlib`, one needs first instantiate `CryptContext`, Then using `hash()` to generate the hashed password from the plain password. `verify()` can be used to check whether a plain password matches the hashed password.

``` python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

pwd_context.hash(password)
pwd_context.verify(plain_password, hashed_password)
```

Notice that a plain password can have several corresponding hashed passwords.